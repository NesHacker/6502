{
  function assignment (left, right) {
    return {
      type: 'assignment',
      left,
      right
    }
  }

  function command (name, params = {}) {
    return {
      type: 'command',
      name,
      params
    }
  }

  function addressingMode (mode, value) {
    return {
      mode,
      value
    }
  }

  function identifier (text) {
    const value = text.length == 1 ? text[0] : text[0] + text[1].join('')
    return { type: 'identifier', value }
  }

  function instruction (name, mode) {
    return {
      type: 'instruction',
      name,
      mode
    }
  }

  function label (name, params = {}) {
    return {
      type: 'label',
      name,
      params
    }
  }

  function number (base, digits) {
    return {
      type: 'number',
      base,
      value: parseInt(digits.join(''), base)
    }
  }
}

start = _ statement:statement _ {
  return statement
}

_ = [ \t\r\n]*
_m = [ \t\r\n]+

statement
  = assignment
  / command
  / instruction

assignment
  = left:identifier _ '=' _ right:expression {
    return assignment(left, right)
  }

command
   = '.PATCH' _ '(' _ address:expression _ ',' _ bankOffset:expression _ ')' {
     return command('patch', { address, bankOffset })
   }
   / '.ENDPATCH' {
     return command('endPatch')
   }

instruction
  = label
  / name:instructionName _m mode:addressingMode {
    return instruction(name, mode)
  }
  / name:instructionName {
    return instruction(name, addressingMode('implicit', ''))
  }

instructionName = name:identifier {
  if (name.value.length !== 3) {
    throw new Error('Invalid instruction name:', name)
  }
  return name.value.toLowerCase()
}

addressingMode
  = 'A'{
    return addressingMode('accumulator', 'A')
  }
  / value:expression _ ',' _ [xX] {
    return addressingMode('xIndex', value)
  }
  / value:expression _ ',' _ [yY] {
    return addressingMode('yIndex', value)
  }
  / value:expression {
    return addressingMode('expression', value)
  }
  / '*' sign:[+\-] amount:[0-9]+ {
    const value = (sign === '-' ? -1 : 1) * parseInt(amount.join(''))
    return addressingMode('relative', value)
  }
  / '@' label:identifier {
    return addressingMode('relativeLabel', '@' + label.value)
  }
  / '(' _ value:expression _ ')' {
    return addressingMode('indirect', value)
  }
  / '(' _ value:expression _ ',' _ [xX] _ ')' {
    return addressingMode('indexedIndirect', value)
  }
  / '(' _ value:expression _ ')' _ ',' _ [yY] {
    return addressingMode('indirectIndexed', value)
  }

label
  = '@' name:identifier ':' {
    return label(name, { local: true })
  }
  / name:identifier ':' {
    return label(name)
  }

expression
  = identifier
  / immediate
  / number

identifier = text:([a-zA-Z_][a-zA-Z0-9_]+) {
  return identifier(text)
}

immediate = '#' number:number {
  return { type: 'immediate', number }
}

number
  = '%' digits:[01]+ { return number(2, digits) }
  / digits:[0-9]+ { return number(10, digits) }
  / '$' digits:[0-9a-fA-F]+ { return number(16, digits) }
