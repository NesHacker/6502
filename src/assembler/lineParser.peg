{
  const ParseNode = require('./ParseNode')
}

start = _ statement:statement _ {
  return statement
}

_ = [ \t\r\n]*
_m = [ \t\r\n]+

statement
  = assignment
  / command
  / instruction

assignment
  = left:identifier _ '=' _ right:expression {
    return ParseNode.assignment(left, right)
  }

command
  = '.' name:command_name _ '(' _ head:expression tail:(_ ',' _ expression)* _ ')' {
    return ParseNode.command(name, [head].concat(tail.map(ary => ary[3])))
  }
  / '.' name:command_name {
    return ParseNode.command(name)
  }

command_name = name:[A-Z_]+ {
  return name.join('')
}

instruction
  = label
  / name:instructionName _m mode:addressingMode {
    return ParseNode.instruction(name, mode)
  }
  / name:instructionName {
    return ParseNode.instruction(name, ParseNode.addressingMode('implicit', ''))
  }

instructionName = name:identifier {
  if (name.value.length !== 3) {
    throw new Error('Invalid instruction name:', name)
  }
  return name.value.toLowerCase()
}

addressingMode
  = [aA] {
    return ParseNode.addressingMode('accumulator', 'A')
  }
  / value:expression _ ',' _ [xX] {
    return ParseNode.addressingMode('xIndex', value)
  }
  / value:expression _ ',' _ [yY] {
    return ParseNode.addressingMode('yIndex', value)
  }
  / value:expression {
    return ParseNode.addressingMode('expression', value)
  }
  / '*' sign:[+\-] amount:[0-9]+ {
    const value = (sign === '-' ? -1 : 1) * parseInt(amount.join(''))
    return ParseNode.addressingMode('relative', value)
  }
  / '@' label:identifier {
    return ParseNode.addressingMode('relativeLabel', '@' + label.value)
  }
  / '(' _ value:expression _ ')' {
    return ParseNode.addressingMode('indirect', value)
  }
  / '(' _ value:expression _ ',' _ [xX] _ ')' {
    return ParseNode.addressingMode('indexedIndirect', value)
  }
  / '(' _ value:expression _ ')' _ ',' _ [yY] {
    return ParseNode.addressingMode('indirectIndexed', value)
  }

label
  = '@' name:identifier ':' {
    return ParseNode.label(name, { local: true })
  }
  / name:identifier ':' {
    return ParseNode.label(name)
  }

expression
  = identifier
  / immediate
  / number

identifier = text:([a-zA-Z_][a-zA-Z0-9_]+) {
  return ParseNode.identifier(text)
}

immediate = '#' number:number {
  return ParseNode.immediate(number)
}

number
  = '%' digits:[01]+ {
    return ParseNode.number(2, digits)
  }
  / digits:[0-9]+ {
    return ParseNode.number(10, digits)
  }
  / '$' digits:[0-9a-fA-F]+ {
    return ParseNode.number(16, digits)
  }
